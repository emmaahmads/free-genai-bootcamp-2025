// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: study_sessions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createStudySession = `-- name: CreateStudySession :one
INSERT INTO study_sessions (
    group_id,
    study_activity_id
) VALUES (
    $1, $2
) RETURNING id, group_id, study_activity_id, created_at
`

type CreateStudySessionParams struct {
	GroupID         pgtype.Int4 `json:"group_id"`
	StudyActivityID pgtype.Int4 `json:"study_activity_id"`
}

func (q *Queries) CreateStudySession(ctx context.Context, arg CreateStudySessionParams) (StudySession, error) {
	row := q.db.QueryRow(ctx, createStudySession, arg.GroupID, arg.StudyActivityID)
	var i StudySession
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.StudyActivityID,
		&i.CreatedAt,
	)
	return i, err
}

const createWordReview = `-- name: CreateWordReview :one
INSERT INTO word_review_items (
    word_id,
    study_session_id,
    correct
) VALUES (
    $1, $2, $3
) RETURNING id, word_id, study_session_id, correct, created_at
`

type CreateWordReviewParams struct {
	WordID         pgtype.Int4 `json:"word_id"`
	StudySessionID pgtype.Int4 `json:"study_session_id"`
	Correct        bool        `json:"correct"`
}

func (q *Queries) CreateWordReview(ctx context.Context, arg CreateWordReviewParams) (WordReviewItem, error) {
	row := q.db.QueryRow(ctx, createWordReview, arg.WordID, arg.StudySessionID, arg.Correct)
	var i WordReviewItem
	err := row.Scan(
		&i.ID,
		&i.WordID,
		&i.StudySessionID,
		&i.Correct,
		&i.CreatedAt,
	)
	return i, err
}

const getLastStudySession = `-- name: GetLastStudySession :one
SELECT 
    ss.id, ss.group_id, ss.study_activity_id, ss.created_at,
    sa.name as activity_name,
    g.name as group_name,
    COUNT(wri.id) as review_items_count
FROM study_sessions ss
JOIN study_activities sa ON ss.study_activity_id = sa.id
JOIN groups g ON ss.group_id = g.id
LEFT JOIN word_review_items wri ON ss.id = wri.study_session_id
GROUP BY ss.id, sa.name, g.name
ORDER BY ss.created_at DESC
LIMIT 1
`

type GetLastStudySessionRow struct {
	ID               int32              `json:"id"`
	GroupID          pgtype.Int4        `json:"group_id"`
	StudyActivityID  pgtype.Int4        `json:"study_activity_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	ActivityName     string             `json:"activity_name"`
	GroupName        string             `json:"group_name"`
	ReviewItemsCount int64              `json:"review_items_count"`
}

func (q *Queries) GetLastStudySession(ctx context.Context) (GetLastStudySessionRow, error) {
	row := q.db.QueryRow(ctx, getLastStudySession)
	var i GetLastStudySessionRow
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.StudyActivityID,
		&i.CreatedAt,
		&i.ActivityName,
		&i.GroupName,
		&i.ReviewItemsCount,
	)
	return i, err
}

const getQuickStats = `-- name: GetQuickStats :one
WITH stats AS (
    SELECT 
        COUNT(*) as total_reviews,
        SUM(CASE WHEN correct THEN 1 ELSE 0 END) as correct_reviews
    FROM word_review_items
)
SELECT 
    CASE 
        WHEN total_reviews > 0 THEN (correct_reviews::float / total_reviews::float) * 100 
        ELSE 0 
    END as success_rate,
    (SELECT COUNT(DISTINCT id) FROM study_sessions) as total_study_sessions,
    (SELECT COUNT(*) FROM groups WHERE words_count > 0) as total_active_groups,
    (SELECT COUNT(DISTINCT DATE(created_at))
     FROM study_sessions 
     WHERE created_at >= CURRENT_DATE - INTERVAL '30 days') as study_streak_days
FROM stats
`

type GetQuickStatsRow struct {
	SuccessRate        int32 `json:"success_rate"`
	TotalStudySessions int64 `json:"total_study_sessions"`
	TotalActiveGroups  int64 `json:"total_active_groups"`
	StudyStreakDays    int64 `json:"study_streak_days"`
}

func (q *Queries) GetQuickStats(ctx context.Context) (GetQuickStatsRow, error) {
	row := q.db.QueryRow(ctx, getQuickStats)
	var i GetQuickStatsRow
	err := row.Scan(
		&i.SuccessRate,
		&i.TotalStudySessions,
		&i.TotalActiveGroups,
		&i.StudyStreakDays,
	)
	return i, err
}

const getSessionReviews = `-- name: GetSessionReviews :many
SELECT 
    wri.id, wri.word_id, wri.study_session_id, wri.correct, wri.created_at,
    w.malay,
    w.jawi,
    w.english
FROM word_review_items wri
JOIN words w ON wri.word_id = w.id
WHERE wri.study_session_id = $1
ORDER BY wri.created_at
LIMIT $2 OFFSET $3
`

type GetSessionReviewsParams struct {
	StudySessionID pgtype.Int4 `json:"study_session_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

type GetSessionReviewsRow struct {
	ID             int32              `json:"id"`
	WordID         pgtype.Int4        `json:"word_id"`
	StudySessionID pgtype.Int4        `json:"study_session_id"`
	Correct        bool               `json:"correct"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	Malay          string             `json:"malay"`
	Jawi           string             `json:"jawi"`
	English        string             `json:"english"`
}

func (q *Queries) GetSessionReviews(ctx context.Context, arg GetSessionReviewsParams) ([]GetSessionReviewsRow, error) {
	rows, err := q.db.Query(ctx, getSessionReviews, arg.StudySessionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionReviewsRow{}
	for rows.Next() {
		var i GetSessionReviewsRow
		if err := rows.Scan(
			&i.ID,
			&i.WordID,
			&i.StudySessionID,
			&i.Correct,
			&i.CreatedAt,
			&i.Malay,
			&i.Jawi,
			&i.English,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudyProgress = `-- name: GetStudyProgress :one
SELECT 
    COUNT(DISTINCT word_id) as total_words_studied,
    (SELECT COUNT(*) FROM words) as total_available_words
FROM word_review_items
`

type GetStudyProgressRow struct {
	TotalWordsStudied   int64 `json:"total_words_studied"`
	TotalAvailableWords int64 `json:"total_available_words"`
}

func (q *Queries) GetStudyProgress(ctx context.Context) (GetStudyProgressRow, error) {
	row := q.db.QueryRow(ctx, getStudyProgress)
	var i GetStudyProgressRow
	err := row.Scan(&i.TotalWordsStudied, &i.TotalAvailableWords)
	return i, err
}

const getStudySession = `-- name: GetStudySession :one
SELECT id, group_id, study_activity_id, created_at FROM study_sessions
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetStudySession(ctx context.Context, id int32) (StudySession, error) {
	row := q.db.QueryRow(ctx, getStudySession, id)
	var i StudySession
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.StudyActivityID,
		&i.CreatedAt,
	)
	return i, err
}

const listStudySessions = `-- name: ListStudySessions :many
SELECT 
    ss.id, ss.group_id, ss.study_activity_id, ss.created_at,
    sa.name as activity_name,
    g.name as group_name,
    COUNT(wri.id) as review_items_count
FROM study_sessions ss
JOIN study_activities sa ON ss.study_activity_id = sa.id
JOIN groups g ON ss.group_id = g.id
LEFT JOIN word_review_items wri ON ss.id = wri.study_session_id
GROUP BY ss.id, sa.name, g.name
ORDER BY ss.created_at DESC
LIMIT $1 OFFSET $2
`

type ListStudySessionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListStudySessionsRow struct {
	ID               int32              `json:"id"`
	GroupID          pgtype.Int4        `json:"group_id"`
	StudyActivityID  pgtype.Int4        `json:"study_activity_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	ActivityName     string             `json:"activity_name"`
	GroupName        string             `json:"group_name"`
	ReviewItemsCount int64              `json:"review_items_count"`
}

func (q *Queries) ListStudySessions(ctx context.Context, arg ListStudySessionsParams) ([]ListStudySessionsRow, error) {
	rows, err := q.db.Query(ctx, listStudySessions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStudySessionsRow{}
	for rows.Next() {
		var i ListStudySessionsRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.StudyActivityID,
			&i.CreatedAt,
			&i.ActivityName,
			&i.GroupName,
			&i.ReviewItemsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
